<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Objective Funk on Objective Funk</title>
    <link>http://nsaphra.github.io/</link>
    <description>Recent content in Objective Funk on Objective Funk</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2018</copyright>
    <lastBuildDate>Wed, 20 Apr 2016 00:00:00 +0100</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Model Scheduling</title>
      <link>http://nsaphra.github.io/post/model-scheduling/</link>
      <pubDate>Mon, 13 Aug 2018 15:49:02 +0100</pubDate>
      
      <guid>http://nsaphra.github.io/post/model-scheduling/</guid>
      <description>

&lt;!--
---
bibliography: &#39;models.bib&#39;
csl: &#39;acm-sigchi.csl&#39;
--- --&gt;

&lt;p&gt;Models can be built incrementally by modifying their hyperparameters
during training. This is most common in transfer learning settings, in
which we seek to adapt the knowledge in an existing model for a new
domain or task. The more general problem of continuous learning is also
an obvious application. Even with a predefined data set, however,
incrementally constraining the topology of the network can offer
benefits as regularization.&lt;/p&gt;

&lt;h2 id=&#34;dynamic-hyperparameters&#34;&gt;Dynamic Hyperparameters&lt;/h2&gt;

&lt;p&gt;The easiest incrementally modified models to train may be those in which
hyperparameters are updated at each epoch. In this case, we do not mean
those hyperparameters associated with network topology, such as the
number or dimension of layers. There are many opportunities to adjust
the topology during training, but the model often requires heavy
retraining in order to impose reasonable structure again, as demonstrated clearly in the case of memory networks&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:25&#34;&gt;&lt;a href=&#34;#fn:25&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;. If we
instead focus on the weights associated with regularizers and gates, we
can gradually learn structure without frequent retraining to accommodate
radically altered topologies.&lt;/p&gt;

&lt;h3 id=&#34;curriculum-dropout&#34;&gt;Curriculum Dropout&lt;/h3&gt;

&lt;p&gt;Hinton et al.&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:13&#34;&gt;&lt;a href=&#34;#fn:13&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; describes dropout as reducing overfitting by preventing
co-adaptation of feature detectors which happened to perfectly fit the
data. In this interpretation, co-adaptive clusters of neurons are
concurrently activated. Randomly suppressing these neurons forces them
to develop independence.&lt;/p&gt;

&lt;p&gt;In standard dropout, these co-adaptive neurons are treated as equally
problematic at all stages of training. However, Morerio et. al.&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:18&#34;&gt;&lt;a href=&#34;#fn:18&#34;&gt;3&lt;/a&gt;&lt;/sup&gt; posit that early
in training, co-adaptation may represent the beginnings of an optimal
self organization of the network. In this view, these structures mainly
pose the threat of overfitting later in training. The authors therefore
introduce a hyperparameter schedule for the dropout ratio, increasing
the rate of dropout as training continues. To the best of my knowledge,
this is the only proposal of adaptive regularization published.&lt;/p&gt;

&lt;h3 id=&#34;mollifying-networks&#34;&gt;Mollifying Networks&lt;/h3&gt;

&lt;p&gt;Mollifying networks&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:8&#34;&gt;&lt;a href=&#34;#fn:8&#34;&gt;4&lt;/a&gt;&lt;/sup&gt; are, to my knowledge, the only existing
attempt to combine techniques focused on incrementally manipulating the
distribution of data with techniques focused on incrementally
manipulating the representational capacity of the model. Mollifying
networks incrementally lower the temperature of the data through
simulated annealing while simultaneously modifying various
hyperparameters to permit longer-range dependencies. In the case of an
LSTM, they set the output gate to 1, input gate to \(\frac{1}{t}\), and
forget gate to \(1 - \frac{1}{t}\), where \(t\) is the annealing time step.
Using this system, the LSTM initially behaves as a bag-of-words model,
gradually adding the capacity to handle more context at each time step.&lt;/p&gt;

&lt;p&gt;Mollifying networks use a different data schedule for each layer,
annealing the noise in lower layers faster than in higher layers because
lower-level representations are assumed to learn faster.&lt;/p&gt;

&lt;h2 id=&#34;adaptive-architectures&#34;&gt;Adaptive Architectures&lt;/h2&gt;

&lt;p&gt;The hyperparameters most difficult to modify during training may be
those which dictate the topology of the model architecture itself.
Nonetheless, the deep learning literature contains a long history of
techniques which adapt the model architecture during training, often in
response to the parameters being learned. Methods like these can help
search optimally by smoothing functions at the beginning of training,
speed up learning by starting with a simpler model, or compress a model
to fit easily on a phone or embedded device. Most of these methods could
be classified as either growing a model by adding parameters
mid-training or shrinking a model by pruning edges or nodes.&lt;/p&gt;

&lt;h3 id=&#34;architecture-growth&#34;&gt;Architecture Growth&lt;/h3&gt;

&lt;p&gt;Some recent transfer learning strategies have relied on growing
architectures by creating entire new modules focused on the new task
with connections to the existing network&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:10&#34;&gt;&lt;a href=&#34;#fn:10&#34;&gt;5&lt;/a&gt;&lt;/sup&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:21&#34;&gt;&lt;a href=&#34;#fn:21&#34;&gt;6&lt;/a&gt;&lt;/sup&gt;. If the goal is to
instead augment an existing network by adding a small number of
parameters, the problem bears a resemblance to traditional nonparametric
learning, because we need not explicitly limit the model space to begin
with.&lt;/p&gt;

&lt;p&gt;Classical techniques in neural networks such as Cascade Correlation
Networks&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:7&#34;&gt;&lt;a href=&#34;#fn:7&#34;&gt;7&lt;/a&gt;&lt;/sup&gt; and Dynamic Node Creation&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34;&gt;8&lt;/a&gt;&lt;/sup&gt; added new nodes at random
one by one and trained them individually. On modern large-scale
architectures and problems, this is intractable. Furthermore, the main
advantage of such methods is that they approach a minimal model, which
is an aim that modern deep learning practitioners no longer consider
valuable thanks to leaps in computing power in the decades since. Modern
techniques for incrementally growing networks must make 2 decisions: 1)
When (and where) do we add new parameters? 2) How do we train new
parameters?&lt;/p&gt;

&lt;p&gt;Warde-Farley et. al.&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:23&#34;&gt;&lt;a href=&#34;#fn:23&#34;&gt;9&lt;/a&gt;&lt;/sup&gt; add parameters in bulk after training an entire network. The
augmentation takes the form of specialized auxiliary layers added to the
existing network in parallel. These layers are trained on class
boundaries that the original generalist model struggles with. The class
boundaries that require special attention are selected by performing
spectral clustering on the confusion matrix of a holdout data set,
partitioning the classes into challenging subproblems.&lt;/p&gt;

&lt;p&gt;The auxiliary layers are initialized randomly in parallel with the
original generalist system, and then are each trained only on examples
from their assigned partition of the classes. The original generalist
network is held fixed, other than fine-tuning the final classification
layer. The resulting network is a mixture of experts, which was shown to
improve results on an image classification problem.&lt;/p&gt;

&lt;p&gt;Neurogenesis Deep Learning (NDL)&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:6&#34;&gt;&lt;a href=&#34;#fn:6&#34;&gt;10&lt;/a&gt;&lt;/sup&gt;, meanwhile, makes autoencoders
capable of lifelong learning. This strategy updates the topology of an
autoencoder by adding neurons when the model encounters outliers that it
performs especially poorly on. These new parameters are trained
exclusively on those outliers, allowing the existing decoder parameters
to update with much smaller step sizes. Existing encoder parameters
update only if they are connected directly to the new neuron.&lt;/p&gt;

&lt;p&gt;After introducing and training these new neurons, NDL stabilizes the
existing structure of the network using a method the authors call
&amp;ldquo;intrinsic replay&amp;rdquo;. They reconstruct approximations of previously seen
samples and train on these reconstructions.&lt;/p&gt;

&lt;p&gt;Another system that permits lifelong learning is the infinite Restricted
Boltzmann Machine (RBM) &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;#fn:4&#34;&gt;11&lt;/a&gt;&lt;/sup&gt;. This extension of the classic RBM
parameterizes hidden units by unique indices, expressing an ordering.
These indices are used to enforce an order on the growth of the network
by favoring older nodes until they have converged, permitting the system
to grow arbitrarily large. An intriguing approach, but it is not obvious
how to apply similar modifications to networks other than the
idiosyncratic generative architecture of the RBM.&lt;/p&gt;

&lt;p&gt;None of these augmentation techniques support recurrent architectures.
In modern natural language processing settings, this is a fatal
limitation. However, it is possible that some of these techniques may be
adapted for RNNs, especially since training specialized subsystems has
been recently tackled in these environments &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34;&gt;12&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;h3 id=&#34;architecture-pruning&#34;&gt;Architecture Pruning&lt;/h3&gt;

&lt;p&gt;Much recent research has focused on the possibility of pruning edges or
entire neurons from trained networks. This approach is promising not
only for the purpose of compression, but potentially as a way of
increasing the generalizability of a network.&lt;/p&gt;

&lt;h4 id=&#34;pruning-edges&#34;&gt;Pruning Edges&lt;/h4&gt;

&lt;p&gt;Procedures that prune edges rather than entire neurons may not reduce
the dimensional type of the network. However, they will make the network
sparser, leading to possible memory savings. A sparser network also
occupies a smaller parameter space, and may therefore still more
general.&lt;/p&gt;

&lt;p&gt;Han et. al.&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:9&#34;&gt;&lt;a href=&#34;#fn:9&#34;&gt;13&lt;/a&gt;&lt;/sup&gt; takes the basic approach of setting weights to 0 if they fall
below a certain threshold. This approach is highly effective for
compression, because the number of weights to be pruned can be easily
modified through the threshold.&lt;/p&gt;

&lt;p&gt;LeCun et. al.&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:15&#34;&gt;&lt;a href=&#34;#fn:15&#34;&gt;14&lt;/a&gt;&lt;/sup&gt; and Hassibi et. al.&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:11&#34;&gt;&lt;a href=&#34;#fn:11&#34;&gt;15&lt;/a&gt;&lt;/sup&gt; both select weights to prune based on Taylor series
approximation of the change in error resulting from trimming. While
these methods were successful for older shallow networks, performing
these operations on an entire network requires a Hessian matrix to be
computed over all parameters, which is generally intractable for deep
modern architectures. Dong et. al.&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:5&#34;&gt;&lt;a href=&#34;#fn:5&#34;&gt;16&lt;/a&gt;&lt;/sup&gt; presents a more efficient alternative by
performing optimal brain surgery over individual layers instead.&lt;/p&gt;

&lt;h4 id=&#34;pruning-nodes&#34;&gt;Pruning Nodes&lt;/h4&gt;

&lt;p&gt;Pruning entire nodes has the advantage of reducing the entire
dimensionality of the network. It also may be faster than choosing
individual edges to prune, because having more nodes than constituent
edges reduces the number of candidates to consider for pruning.&lt;/p&gt;

&lt;p&gt;He et al.&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:12&#34;&gt;&lt;a href=&#34;#fn:12&#34;&gt;17&lt;/a&gt;&lt;/sup&gt; selects which neuron \(w_i^\ell\) to prune from layer \(\ell\)
with width \(d_{\ell}\) by calculating the importance of each node. They
test several importance metrics, finding that the highest performance
results from using the &amp;lsquo;onorm&amp;rsquo;, or average \(l_1\) norm of the activation
pattern of the node:&lt;/p&gt;

&lt;p&gt;\(\mathrm{onorm}(w_i^\ell) = \frac{1}{d_{\ell+1}} \sum_{j = 1}^{d_{\ell+1}} |w_{ij}^{\ell+1}|\)&lt;/p&gt;

&lt;p&gt;Net-trim &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;18&lt;/a&gt;&lt;/sup&gt; likewise relies on the \(l_1\) norm to induce sparsity.&lt;/p&gt;

&lt;p&gt;Wolfe et al.&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:24&#34;&gt;&lt;a href=&#34;#fn:24&#34;&gt;19&lt;/a&gt;&lt;/sup&gt; compares the results of importance based pruning to a brute force
method that will greedily select a node to be sacrificed based on its
impact on performance. In the brute force method, they rerun the network
on the test data without each node and sort the nodes according to the
error of the resulting network. Their importance metrics are based on
neuron-level versions of the Taylor series approximations of that impact&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:11&#34;&gt;&lt;a href=&#34;#fn:11&#34;&gt;15&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;In the first algorithm tested, they rank all nodes according to their
importance and then remove each node in succession. In the second
algorithm, they re-rank the nodes after each removal, in order to
account for the effects of subnetworks that generate and then cancel. In
the second case, they find that it is possible to prune up to 60% of
nodes in a network trained on mnist without significant loss in
performance. This supports an early observation&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:19&#34;&gt;&lt;a href=&#34;#fn:19&#34;&gt;20&lt;/a&gt;&lt;/sup&gt; that the majority
of parameters in a network are unnecessary, and their effect is limited
to generating and then canceling their own noise. The strength of this
effect supports the idea that backpropagation implicitly trains a
minimal network for the task given.&lt;/p&gt;

&lt;p&gt;Srinivas and Babu&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:22&#34;&gt;&lt;a href=&#34;#fn:22&#34;&gt;21&lt;/a&gt;&lt;/sup&gt; prune with the goal of reducing the redundancy of the network, so
they select nodes to remove based on the similarity of their weights to
other neurons in the same layer. Diversity networks&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:17&#34;&gt;&lt;a href=&#34;#fn:17&#34;&gt;22&lt;/a&gt;&lt;/sup&gt;, meanwhile,
choose based on the diversity of their activation patterns. In order to
sample a diverse selection of nodes, they use a Determinantal Point
Process. This technique minimizes the dependency between nodes sampled.
They followed this pruning process by &lt;a href=&#34;#merging-nodes&#34;&gt;fusing&lt;/a&gt; the nodes pruned back into
the network.&lt;/p&gt;

&lt;p&gt;An intriguing difference emerges between the observations in these
papers. While Mariet and Sra&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:17&#34;&gt;&lt;a href=&#34;#fn:17&#34;&gt;22&lt;/a&gt;&lt;/sup&gt; find that in deeper layers they sample more nodes
from the DPP, Philipp and Carbonell &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:24&#34;&gt;&lt;a href=&#34;#fn:24&#34;&gt;19&lt;/a&gt;&lt;/sup&gt; prune more nodes by brute force in the deeper
layer of a 2-layer network. In other words, diversity networks retain
more nodes at deeper layers while greedy brute force approaches remove
more from the same layers. These results point to fundamental
differences between the respective outcomes of these algorithms and
warrant further investigation.&lt;/p&gt;

&lt;h5 id=&#34;merging-nodes&#34;&gt;Merging Nodes&lt;/h5&gt;

&lt;p&gt;Mariet and Sra&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:17&#34;&gt;&lt;a href=&#34;#fn:17&#34;&gt;22&lt;/a&gt;&lt;/sup&gt; found that performance increased after their DPP-based pruning if
they then merged the pruned nodes back into the network. They achieved
this by re-weighting the remaining nodes in the pruned layer to minimize
the difference in activation outputs before and after pruning:&lt;/p&gt;

&lt;p&gt;\( \min_{\tilde{w}_{ij} \in \mathbb{R}} | \sum_{i=1}^k \tilde{w}_{ij} v_i -  \sum_{i=1}^{d_{\ell}} w_{ij} v_i |_2 \)&lt;/p&gt;

&lt;p&gt;Because the DPP is focused on selecting an independent set of neurons,
it seems likely that pruning will select at least 1 node within any
given noise cancellation system to keep, since those cancellation
subnetworks are by necessity highly dependent. The merging step in that
case would merge the noise canceling components back into the noise
generating nodes or vice versa. This would make merging a particular
necessity in diversity networks, but it may still present a tractable
alternative to retraining after a different pruning algorithm.&lt;/p&gt;

&lt;h3 id=&#34;nonparametric-neural-networks&#34;&gt;Nonparametric Neural Networks&lt;/h3&gt;

&lt;p&gt;The pruning and growing strategies are combined in only one work, to my
knowledge. Nonparametric Neural Networks (NNNs)&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:20&#34;&gt;&lt;a href=&#34;#fn:20&#34;&gt;23&lt;/a&gt;&lt;/sup&gt; combine adding
neurons with imposing a sparsity-inducing penalty over neurons. For a
feedforward network with \(N^L\) layers, authors introduce 2 such
regularizers, a &amp;ldquo;fan-in&amp;rdquo; and a &amp;ldquo;fan-out&amp;rdquo; variant:&lt;/p&gt;

&lt;p&gt;\(
\Omega_{\mathrm{in}} = \sum_{\ell = 1}^{N^L} \sum_{j = 1}^{d_\ell} \left( \sum_{i = 1}^{d_{\ell}} |w_{ij}^{\ell+1}|^p \right)^{\frac{1}{p}}\)&lt;/p&gt;

&lt;p&gt;\(\Omega_{\mathrm{out}} = \sum_{\ell = 1}^{N^L}  \sum_{i = 1}^{d_{\ell}}  \left( \sum_{j = 1}^{d_\ell+1} |w_{ij}^{\ell}|^p \right)^{\frac{1}{p}}\)&lt;/p&gt;

&lt;p&gt;In other words, the fan-in variant penalizes the \(p\)-norm of the inputs
to each neuron, while the fan-out of variant penalizes the \(p\)-norm of
the outputs from each neuron. In the case of feedforward networks,
either of these regularizers can be added to the loss function with any
positive weight \(\lambda\) and \(0 &amp;lt; p &amp;lt; \infty\) to guarantee that the
objective will converge at some finite number of neurons.&lt;/p&gt;

&lt;p&gt;NNNs offer a combination of beneficial strategies for adapting the
network. In particular with \(p = 1\) or 2, induces sparsity by applying
pressure to form &lt;em&gt;zero-valued neurons&lt;/em&gt;, or neurons which have either a
fan-in or fan-out value of 0. At intervals we can remove these
zero-valued neurons which result. At the same time, we can introduce new
zero-valued neurons at different locations in the network, and the
regularizer guarantees the objective will converge, so we can stop
adding neurons at any point that performance begins to decline.&lt;/p&gt;

&lt;p&gt;However, there are clear issues with this approach. The first obvious
limitation is that this regularizer cannot be applied in any network
with recurrences. This constraint reduces the strategy&amp;rsquo;s usefulness in
many natural language domains where state-of-the-art performance
requires a RNN.&lt;/p&gt;

&lt;p&gt;Another disadvantage to this method is the choice to insert zero-valued
neurons by initializing either the input or output weight vector as 0
and randomly initializing the other associated vector. We therefore
retrain the entire network with each interval, rather than intelligently
initializing and training the new node to accelerate convergence. While
this approach may converge to an optimal number of nodes, it does
nothing to accelerate training or help new nodes specialize.&lt;/p&gt;

&lt;p&gt;Finally, this approach adds and removes entire neurons to create a final
dense network. It therefore forfeits the potential regularization
advantages of the sparser networks which result from instead pruning
weights.&lt;/p&gt;

&lt;h2 id=&#34;teacher-student-approaches&#34;&gt;Teacher/Student Approaches&lt;/h2&gt;

&lt;p&gt;It is also possible to produce a larger or smaller model based on an
existing network by fresh training. When investigating any adaptive
architecture, it is crucial to compare with a baseline which uses the
previous state of the network as a teacher to a student network which
has the new architecture.&lt;/p&gt;

&lt;p&gt;The approach of teacher/student learning, in which the teacher network&amp;rsquo;s
outputs layer are used in lieu of or in addition to true labels, was
introduced in the particular case of distillation learning &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:14&#34;&gt;&lt;a href=&#34;#fn:14&#34;&gt;24&lt;/a&gt;&lt;/sup&gt;.
Distillation is a technique for compressing a large ensemble or
generally expensive classifier with high performance. A smaller network
is trained using an objective that combines a loss function applied to true labels with cross-entropy against the logit layer of the large teacher network. In addition to compression, teacher/student learning is effective for domain adaptation technique &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:16&#34;&gt;&lt;a href=&#34;#fn:16&#34;&gt;25&lt;/a&gt;&lt;/sup&gt;, suggesting it may be useful for adapting to a new time step in a data schedule.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:25&#34;&gt;Sachan, Mrinmaya, and Eric Xing. &amp;ldquo;Easy questions first? a case study on curriculum learning for question answering.&amp;rdquo; &lt;em&gt;Proceedings of the 54th Annual Meeting of the Association for Computational Linguistics&lt;/em&gt; (Volume 1: Long Papers). Vol. 1. 2016.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:25&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:13&#34;&gt;Geoffrey E. Hinton, Nitish Srivastava, Alex Krizhevsky, Ilya Sutskever, and Ruslan Salakhutdinov. 2012. Improving neural networks by preventing co-adaptation of feature detectors. &lt;em&gt;CoRR&lt;/em&gt; abs/1207.0580.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:13&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:18&#34;&gt;Pietro Morerio, Jacopo Cavazza, Riccardo Volpi, Rene Vidal, and Vittorio Murino. 2017. Curriculum Dropout. &lt;em&gt;arXiv:1703.06229 [^cs, stat]:&lt;/em&gt;. Retrieved March 22, 2017 from &lt;a href=&#34;http://arxiv.org/abs/1703.06229&#34; target=&#34;_blank&#34;&gt;http://arxiv.org/abs/1703.06229&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:18&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:8&#34;&gt;Caglar Gulcehre, Marcin Moczulski, Francesco Visin, and Yoshua Bengio. 2016. Mollifying Networks. &lt;em&gt;arXiv:1608.04980 [^cs]:&lt;/em&gt;. Retrieved October 7, 2016 from &lt;a href=&#34;http://arxiv.org/abs/1608.04980&#34; target=&#34;_blank&#34;&gt;http://arxiv.org/abs/1608.04980&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:8&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:10&#34;&gt;Kazuma Hashimoto, Caiming Xiong, Yoshimasa Tsuruoka, and Richard Socher. 2017. A Joint Many-Task Model: Growing a Neural Network for Multiple NLP Tasks. In &lt;em&gt;arXiv:1611.01587 [^cs]:&lt;/em&gt;. Retrieved November 11, 2016 from &lt;a href=&#34;http://arxiv.org/abs/1611.01587&#34; target=&#34;_blank&#34;&gt;http://arxiv.org/abs/1611.01587&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:10&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:21&#34;&gt;Andrei A. Rusu, Neil C. Rabinowitz, Guillaume Desjardins, Hubert Soyer, James Kirkpatrick, Koray Kavukcuoglu, Razvan Pascanu, and Raia Hadsell. 2016. Progressive Neural Networks. &lt;em&gt;arXiv:1606.04671 [^cs]:&lt;/em&gt;. Retrieved September 14, 2016 from &lt;a href=&#34;http://arxiv.org/abs/1606.04671&#34; target=&#34;_blank&#34;&gt;http://arxiv.org/abs/1606.04671&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:21&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:7&#34;&gt;Scott E. Fahlman and Christian Lebiere. 1989. The cascade-correlation learning architecture. Retrieved November 30, 2016 from &lt;a href=&#34;http://repository.cmu.edu/compsci/1938/&#34; target=&#34;_blank&#34;&gt;http://repository.cmu.edu/compsci/1938/&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:7&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;Ash. 1989. Dynamic node creation in backpropagation networks. In &lt;em&gt;International 1989 Joint Conference on Neural Networks&lt;/em&gt;, 623 vol.2. &lt;a href=&#34;https://doi.org/10.1109/IJCNN.1989.118509&#34; target=&#34;_blank&#34;&gt;https://doi.org/10.1109/IJCNN.1989.118509&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:23&#34;&gt;David Warde-Farley, Andrew Rabinovich, and Dragomir Anguelov. 2014. Self-informed neural network structure learning. &lt;em&gt;arXiv preprint arXiv:1412.6563&lt;/em&gt;. Retrieved June 9, 2016 from &lt;a href=&#34;http://arxiv.org/abs/1412.6563&#34; target=&#34;_blank&#34;&gt;http://arxiv.org/abs/1412.6563&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:23&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:6&#34;&gt;Timothy J. Draelos, Nadine E. Miner, Christopher C. Lamb, Craig M. Vineyard, Kristofor D. Carlson, Conrad D. James, and James B. Aimone. 2016. Neurogenesis Deep Learning. &lt;em&gt;arXiv:1612.03770 [^cs, stat]:&lt;/em&gt;. Retrieved February 27, 2017 from &lt;a href=&#34;http://arxiv.org/abs/1612.03770&#34; target=&#34;_blank&#34;&gt;http://arxiv.org/abs/1612.03770&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:6&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:4&#34;&gt;Marc-Alexandre Cote and Hugo Larochelle. 2015. An Infinite Restricted Boltzmann Machine. &lt;em&gt;arXiv:1502.02476 [^cs]:&lt;/em&gt;. Retrieved February 8, 2018 from &lt;a href=&#34;http://arxiv.org/abs/1502.02476&#34; target=&#34;_blank&#34;&gt;http://arxiv.org/abs/1502.02476&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:4&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;Shlomo E. Chazan, Jacob Goldberger, and Sharon Gannot. 2017. Deep recurrent mixture of experts for speech enhancement. &lt;em&gt;2017 IEEE Workshop on Applications of Signal Processing to Audio and Acoustics (WASPAA)&lt;/em&gt;: 359&amp;ndash;363.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:3&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:9&#34;&gt;Song Han, Jeff Pool, John Tran, and William J. Dally. 2015. Learning both Weights and Connections for Efficient Neural Networks. &lt;em&gt;arXiv:1506.02626 [^cs]:&lt;/em&gt;. Retrieved May 26, 2016 from &lt;a href=&#34;http://arxiv.org/abs/1506.02626&#34; target=&#34;_blank&#34;&gt;http://arxiv.org/abs/1506.02626&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:9&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:15&#34;&gt;Yann LeCun, John S. Denker, and Sara A. Solla. 1990. Optimal brain damage. In &lt;em&gt;Advances in neural information processing systems&lt;/em&gt;, 598&amp;ndash;605.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:15&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:11&#34;&gt;Babak Hassibi, David G. Stork, and Gregory J. Wolff. 1993. Optimal brain surgeon and general network pruning. In &lt;em&gt;Neural Networks, 1993., IEEE International Conference on&lt;/em&gt;, 293&amp;ndash;299.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:11&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:5&#34;&gt;Xin Dong, Shangyu Chen, and Sinno Jialin Pan. 2017. Learning to Prune Deep Neural Networks via Layer-wise Optimal Brain Surgeon. &lt;em&gt;arXiv:1705.07565 [^cs]:&lt;/em&gt;. Retrieved from &lt;a href=&#34;http://arxiv.org/abs/1705.07565&#34; target=&#34;_blank&#34;&gt;http://arxiv.org/abs/1705.07565&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:5&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:12&#34;&gt;Tianxing He, Yuchen Fan, Yanmin Qian, Tian Tan, and Kai Yu. 2014. Reshaping deep neural network for fast decoding by node-pruning. &lt;em&gt;2014 IEEE International Conference on Acoustics, Speech and Signal Processing (ICASSP)&lt;/em&gt;: 245&amp;ndash;249.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:12&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:1&#34;&gt;Aghasi, Alireza, et al. &amp;ldquo;Net-trim: Convex pruning of deep neural networks with performance guarantee.&amp;rdquo; &lt;em&gt;Advances in Neural Information Processing Systems&lt;/em&gt;. 2017. &lt;a href=&#34;http://arxiv.org/abs/1611.05162&#34; target=&#34;_blank&#34;&gt;http://arxiv.org/abs/1611.05162&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:24&#34;&gt;Nikolas Wolfe, Aditya Sharma, Lukas Drude, and Bhiksha Raj. 2017. &amp;ldquo;The Incredible Shrinking Neural Network: New Perspectives on Learning Representations Through The Lens of Pruning.&amp;rdquo;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:24&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:19&#34;&gt;Michael C. Mozer and Paul Smolensky. 1989. Using Relevance to Reduce Network Size Automatically.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:19&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:22&#34;&gt;Suraj Srinivas and R. Venkatesh Babu. 2015. Data-free parameter pruning for deep neural networks. &lt;em&gt;arXiv preprint arXiv:1507.06149&lt;/em&gt;. Retrieved October 5, 2016 from &lt;a href=&#34;http://arxiv.org/abs/1507.06149&#34; target=&#34;_blank&#34;&gt;http://arxiv.org/abs/1507.06149&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:22&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:17&#34;&gt;Zelda Mariet and Suvrit Sra. 2015. Diversity Networks: Neural Network Compression Using Determinantal Point Processes. &lt;em&gt;arXiv:1511.05077 [^cs]:&lt;/em&gt;. Retrieved February 9, 2018 from &lt;a href=&#34;http://arxiv.org/abs/1511.05077&#34; target=&#34;_blank&#34;&gt;http://arxiv.org/abs/1511.05077&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:17&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:20&#34;&gt;George Philipp and Jaime G. Carbonell. 2017. Nonparametric Neural Networks. In &lt;em&gt;arXiv:1712.05440 [^cs]:&lt;/em&gt;. Retrieved February 18, 2018 from &lt;a href=&#34;http://arxiv.org/abs/1712.05440&#34; target=&#34;_blank&#34;&gt;http://arxiv.org/abs/1712.05440&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:20&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:14&#34;&gt;Geoffrey Hinton, Oriol Vinyals, and Jeff Dean. 2015. Distilling the Knowledge in a Neural Network. &lt;em&gt;arXiv:1503.02531 [^cs, stat]:&lt;/em&gt;. Retrieved September 22, 2016 from &lt;a href=&#34;http://arxiv.org/abs/1503.02531&#34; target=&#34;_blank&#34;&gt;http://arxiv.org/abs/1503.02531&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:14&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:16&#34;&gt;Jinyu Li, Michael L. Seltzer, Xi Wang, Rui Zhao, and Yifan Gong. 2017. Large-Scale Domain Adaptation via Teacher-Student Learning. &lt;em&gt;arXiv:1708.05466 [^cs]:&lt;/em&gt;. Retrieved August 26, 2017 from &lt;a href=&#34;http://arxiv.org/abs/1708.05466&#34; target=&#34;_blank&#34;&gt;http://arxiv.org/abs/1708.05466&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:16&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Privacy Policy</title>
      <link>http://nsaphra.github.io/privacy/</link>
      <pubDate>Thu, 28 Jun 2018 00:00:00 +0100</pubDate>
      
      <guid>http://nsaphra.github.io/privacy/</guid>
      <description>&lt;p&gt;&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Understanding Latent Dirichlet Allocation</title>
      <link>http://nsaphra.github.io/post/lda/</link>
      <pubDate>Mon, 09 Jul 2012 00:00:00 +0100</pubDate>
      
      <guid>http://nsaphra.github.io/post/lda/</guid>
      <description>&lt;p&gt;&lt;em&gt;[Note - This is a repost of a post I made on my old blog while I was in undergrad. I&amp;rsquo;m including it in case someone finds it useful, since my old blog is defunct. I haven&amp;rsquo;t significantly edited it, so I&amp;rsquo;m sorry if it doesn&amp;rsquo;t fit into my current style.]&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;This post is directed to a lay CS audience. I am an undergraduate in CS, so I consider myself part of that audience. If you&amp;rsquo;re awesome at machine learning already and don&amp;rsquo;t want to help me along here, just read the paper.&lt;/p&gt;

&lt;p&gt;Latent Dirichlet Allocation (LDA) is a common method of topic modeling.  That is, if I have a document and want to figure out if it&amp;rsquo;s a sports  article or a mathematics paper, I can use LDA to build a system that  looks at other sports articles or mathematics papers and automatically  decides whether this unseen document&amp;rsquo;s topic is sports or math.&lt;/p&gt;

&lt;p&gt;To LDA, a document is just a collection of topics where  each topic has some particular probability of generating a particular  word. For our potential sports article, the word &amp;ldquo;average&amp;rdquo; appears 4  times. What&amp;rsquo;s the probability of a sports topic generating that many  instances of &amp;ldquo;average&amp;rdquo;? We determine this by looking at each training  document as a &amp;ldquo;bag of words&amp;rdquo; pulled from a distribution selected by a Dirichlet process.&lt;/p&gt;

&lt;p&gt;Dirichlet is a distribution specified by a vector parameter $$\alpha$$ containing some \(\alpha_i\) corresponding to each topic  \(i\), which we write as \(\textrm{Dir}(\alpha)\). The formula for computing the probability density function for each topic vector \(x\) is proportional to the product over all topics \(i\) of \(x_i \alpha_i\). \(x_i\) is the probability that the topic is \(i\), so the items in \(x\) must sum to 1. That keeps you from getting arbitrarily large probabilities by giving arbitrarily large values of \(x\).&lt;/p&gt;

&lt;p&gt;Confused? Ready for a picture ripped off Wikipedia?&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://commons.wikimedia.org/wiki/File:Dirichlet_distributions.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://upload.wikimedia.org/wikipedia/commons/thumb/3/3e/Dirichlet_distributions.png/695px-Dirichlet_distributions.png&#34; alt=&#34;Dirichlet Distributions&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Those graphs all show Dirichlet distributions for three topics. That  triangle at the bottom has one side for each topic, and the closer a point on the triangle is to side \(i\) the higher the probability of topic \(i\).  The purple curve is the probability density function over the mixture  of topics. See how the edges of the triangle all have probability 0? We  said that the pdf is proportional to  \(x_i \alpha_i\), so if \(x_i\) is 0, the probability of that mixture of topics is 0. That restricts  our model a bit and ensures that we never are totally certain about the  topic of a document.&lt;/p&gt;

&lt;p&gt;Okay, we&amp;rsquo;ve got &amp;ldquo;Dirichlet&amp;rdquo;, so let&amp;rsquo;s pop back up to the concept of LDA.  If we want to find that mixture of topics for a document, we first need  to determine the value of each  \(x_i\). That means we&amp;rsquo;ve got another Dirichlet distribution in our model for each topic i where instead of the sides of the triangle being topics, they&amp;rsquo;re words.  Picture the topic &amp;ldquo;sports article&amp;rdquo; like those distributions above, but  instead of sitting on triangles they&amp;rsquo;re on shapes with so many sides the shapes go into as many dimensions as we have topics.. If &amp;ldquo;average&amp;rdquo; appears in a sports  article, the bump pushes closer to the side for &amp;ldquo;average&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;The Latent part of LDA comes into play because in  statistics, a variable we have to infer rather than directly observing  is called a &amp;ldquo;latent variable&amp;rdquo;. We&amp;rsquo;re only directly observing the words  and not the topics, so the topics themselves are latent variables (along  with the distributions themselves).&lt;/p&gt;

&lt;p&gt;LDA assumes that each document k is generated by:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;From our Dirichlet distribution for k, sample a random  distribution of topics. That is, pick a place on that triangle that is  associated with a certain probability of generating each topic. If we   choose a place very close to the &amp;ldquo;sports article&amp;rdquo; edge, we have a higher  probability of picking &amp;ldquo;sports article&amp;rdquo;. The probability of picking a  particular place on the triangle is described by the pdf of the  Dirichlet distribution (the placement of the purple mound).&lt;/li&gt;
&lt;li&gt;For each topic, pick a distribution of words for that topic from the Dirichlet for that topic.&lt;/li&gt;
&lt;li&gt;For each word in document \(k\),

&lt;ol&gt;
&lt;li&gt;From the distribution of topics selected for \(k\), sample a topic, like &amp;ldquo;sports article&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;From the distribution selected for &amp;ldquo;sports article&amp;rdquo;, pick the current word.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;So let&amp;rsquo;s say your first four words all come from baseball and your  document maybe starts off &amp;ldquo;average the bat bat&amp;rdquo;. If that&amp;rsquo;s not how you  tend to write, that&amp;rsquo;s okay. All models are wrong.&lt;/p&gt;

&lt;p&gt;The important thing to understand is that your Dirichlet priors are distribution of distributions, which are selected to generate each word.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;re generally not just making these distributions for the heck of it  or to actually generate documents. We want to figure out what topic was  probably used for each word by our lazy writer who randomly generates each word. Maybe it&amp;rsquo;s been a while since you took probability, but do you remember this guy?
\[ P(A|B) = \frac{P(B|A) P(A)}{P(B)} \]&lt;/p&gt;

&lt;p&gt;This is Bayes&amp;rsquo; Theorem. We already know the probability of generating a particular word given a topic according to our model. That&amp;rsquo;s the probability of sampling that word from the topic&amp;rsquo;s word distribution. So that&amp;rsquo;s \( P(B|A) \) where \( B \) is the event of &amp;ldquo;average&amp;rdquo; being generated for the current word and A is the event of picking the topic &amp;ldquo;sports article&amp;rdquo;. \(P(A)\) is the probability of &amp;ldquo;sports article&amp;rdquo; being picked from the document&amp;rsquo;s topic distribution. \( P(B) \) is the probability of &amp;ldquo;average&amp;rdquo; being generated at all, which is the sum over all topic selections \(A\) of \(P(B|A)P(A)\). Now we can use Bayes to find \(P(A|B)\), the probability that topic \(A\) generated word \(B\).&lt;/p&gt;

&lt;p&gt;So now we know how to figure out the probability of each topic per word.  Now we already know that our documents are assumed to be a mix of  topics, but we want to find the most likely dominant topic. The lazy  writer generates each word independently of each other word, so the  overall probability of a topic throughout the document is the product of  \(P(A|B)\) at each word \(B\). Just pick the most likely topic across the words.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
